Date_timestamp          name,         unique_id,score,total,Time_Taken,answers_json,                                                                      detailed
2025-09-15 17:23:02,shinde sanket,835,8,15,210,[3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3],[{"q": "In Python, which optimization does the functools.lru_cache decorator provide?", "options": ["Thread safety", "Code compilation to C", "Runtime type checking", "Function memoization"], "correct_index": 3, "selected_index": 3, "marked": false, "visited": true}, {"q": "Output?\npublic class Main {\n    public static void main(String[] args) {\n        String s = \"abc\";\n        StringBuilder sb = new StringBuilder(\"abc\");\n        System.out.println(s.equals(sb) + \" \" + sb.equals(s));\n    }\n}", "options": ["false false", "true true", "false true", "true false"], "correct_index": 0, "selected_index": 3, "marked": false, "visited": true}, {"q": "What is the amortized time complexity of splay tree operations (insert, search, delete)?", "options": ["O(n)", "O(1)", "O(n log n)", "O(log n)"], "correct_index": 3, "selected_index": 3, "marked": false, "visited": true}, {"q": "What is the result of using volatile in Java?", "options": ["Makes variables immutable", "Synchronizes all threads automatically", "Guarantees atomicity for compound operations", "Prevents instruction reordering and ensures visibility"], "correct_index": 3, "selected_index": 3, "marked": false, "visited": true}, {"q": "In Java, what is the primary difference between WeakReference and SoftReference?", "options": ["Both behave the same", "Weak references are cleared eagerly, soft references only under memory pressure", "Weak references are cleared less aggressively than soft references", "Soft references are cleared before weak references"], "correct_index": 1, "selected_index": 3, "marked": false, "visited": true}, {"q": "In Python’s memory management, what is the primary role of reference counting combined with garbage collection?", "options": ["Eliminates need for manual memory management like malloc", "Improves execution speed", "Prevents memory leaks completely", "Detects and frees cyclic references"], "correct_index": 3, "selected_index": 3, "marked": false, "visited": true}, {"q": "Which graph algorithm guarantees shortest paths even if there are negative edge weights (but no negative cycles)?", "options": ["Prim’s algorithm", "Kruskal’s algorithm", "Dijkstra’s algorithm", "Bellman-Ford algorithm"], "correct_index": 3, "selected_index": 3, "marked": false, "visited": true}, {"q": "Which Java feature ensures that all threads see consistent values of a final field once the constructor finishes execution?", "options": ["Volatile semantics", "Happens-before guarantee", "Escape analysis", "Atomicity guarantee"], "correct_index": 1, "selected_index": 3, "marked": false, "visited": true}, {"q": "What is the worst-case time complexity of building a suffix array using the prefix-doubling algorithm?", "options": ["O(n²)", "O(n log n)", "O(n)", "O(n log² n)"], "correct_index": 3, "selected_index": 3, "marked": false, "visited": true}, {"q": "Which garbage collection algorithm in modern JVM uses region-based memory management and divides the heap into small equal-sized regions?", "options": ["CMS Collector", "Serial Collector", "G1 Garbage Collector", "Parallel Scavenge"], "correct_index": 2, "selected_index": 3, "marked": false, "visited": true}, {"q": "Output?\ndef f(val, lst=[]):\n    lst.append(val)\n    return lst\n\nprint(f(10))\nprint(f(20, []))\nprint(f(30))", "options": ["[10], [20], [30, 10]", "[10], [20], [10, 30]", "[10], [20], [30]", "[10], [20], [10, 30]"], "correct_index": 1, "selected_index": 3, "marked": false, "visited": true}, {"q": "In Java memory model, what happens if a thread reads a variable without proper synchronization and the variable is cached in CPU registers instead of main memory?", "options": ["JVM prevents such caching", "It always throws a ConcurrentModificationException", "The variable is automatically synchronized", "The thread may see stale values (visibility issue)"], "correct_index": 3, "selected_index": 3, "marked": false, "visited": true}, {"q": "In a Union-Find (Disjoint Set Union) structure with union by rank and path compression, what is the time complexity of a single operation (union or find) in amortized analysis?", "options": ["O(log n)", "O(1)", "O(n)", "O(α(n)) (inverse Ackermann function)"], "correct_index": 3, "selected_index": 3, "marked": false, "visited": true}, {"q": "Which Python module allows you to create and manage lightweight cooperative threads scheduled by an event loop?", "options": ["concurrent.futures", "multiprocessing", "asyncio", "threading"], "correct_index": 2, "selected_index": 3, "marked": false, "visited": true}, {"q": "Which of the following best explains why Python integers can grow arbitrarily large (unlike C/C++ int)?", "options": ["Python dynamically allocates integers on heap with arbitrary precision", "Python stores integers in registers only", "Python restricts int to 64 bits internally", "Python automatically converts int to float when needed"], "correct_index": 0, "selected_index": 3, "marked": false, "visited": true}]
